测试驱动的开发模式（TDD）
========================

#3、稳固的中间层#
在正统的Java设计领域通常把 POJO 对象分为三类:
>- VO (Value Object) 值对象
*通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。*
- BO (Business Object) 业务对象
*从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。*   
- PO (Persistant Object) 持久对象
*在o/r映射的时候出现的概念，如果没有o/r映射，没有这个概念存在了。通常对应数据模型(数据库),本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。*

我们要做的就是实现 **BO**，即业务对象。业务对象中包含业务逻辑，可以独立存在，通过 **VO** 适配不同的视图。这种适配包括不同体系架构的适应性，使之独立于界面实现。

*实现**BO**有什么好处吗，好像很麻烦耶。

好处就是，你可以踢开数据库存储，踢开界面实现，单独对**BO**编写单元测试。
我经常想到下面这句话
>**我想到了一个绝妙的实现方法，只是没想好放到哪里合适。**

很多不知道该放到哪里的代码，其实应该放到**BO**中。

**BO**包含了业务逻辑和必要的数据，自身形成一个自完备的逻辑体系，不依赖任何具体实现，是绝佳的业务抽象层。同时构造和回收的成本很低。


好了，让我们重新整理一下这个发展的过程。
第一次，我们跟着直觉，写出一个基于界面控件的实现，放好控件然后构思各个操作的响应事件如何实现。
第二次，了解了MVC的设计方式，把控制功能和展现方式放在一起，独立出一个独立的实体类，构造了简单的组件结构。
第三次，彻底和界面实现分离，业务逻辑独立实现，一套业务逻辑实现适应各种UI。

每一次分拆，都让我们更加专注于具体领域的逻辑模型。在实际的系统中，每个界面都有很多功能，开发的过程也经常会有反复修改，如果不分离出稳固的中间层，捉虫子的工作就永远也不会结束。

*比如，OA系统的动态业务表单为例，如果以为界面为中心的实现方式，会导致业务逻辑，存储层、业务逻辑层和表示层代码混杂在一起，既无从下手进行性能优化、也无法产生中间结果进行缓冲。*

**BO**构建的中间层包括了业务数据和逻辑，向上可以转换成表示层所用的**VO**，向下可以转换为数据层的**PO**，自身也可有独立缓存，结合缓存框架和IOC框架使用。

>**代码是相互依存的，如同一句话不会单独存在。**

> Written with [StackEdit](https://stackedit.io/).