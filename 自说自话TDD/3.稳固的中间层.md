自说自话 TDD
========================

#3、稳固的中间层#
在正统的Java设计领域通常把 POJO 对象分为三类:
>- VO (Value Object) 值对象
*通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同DTO(数据传输对象),在web上传递。*
- BO (Business Object) 业务对象
*从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。*   
- PO (Persistant Object) 持久对象
*在o/r映射的时候出现的概念，如果没有o/r映射，没有这个概念存在了。通常对应数据模型(数据库),本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。*

我们要做的就是实现 **BO**，即业务对象。业务对象中包含业务逻辑，可以独立存在，通过 **VO** 适配不同的视图。这种适配包括不同体系架构的适应性，使之独立于界面实现。

*实现**BO**有什么好处吗，好像很麻烦耶。

好处就是，你可以踢开数据库存储，踢开界面实现，单独对**BO**编写单元测试。
我经常想到下面这句话
>**我想到了一个绝妙的实现方法，只是没想好放到哪里合适。**

很多不知道该放到哪里的代码，其实应该放到**BO**中。

**BO**包含了业务逻辑和必要的数据，自身形成一个自完备的逻辑体系，不依赖任何具体实现，是绝佳的业务抽象层。同时构造和回收的成本很低。


好了，让我们重新整理一下这个发展的过程。
第一次，我们跟着直觉，写出一个基于界面控件的实现，放好控件然后构思各个操作的响应事件如何实现。
第二次，了解了MVC的设计方式，把控制功能和展现方式放在一起，独立出一个独立的实体类，构造了简单的组件结构。
第三次，彻底和界面实现分离，业务逻辑独立实现，一套业务逻辑实现适应各种UI。

每一次分拆，都让我们更加专注于具体领域的逻辑模型。在实际的系统中，每个界面都有很多功能，开发的过程也经常会有反复修改，如果不分离出稳固的中间层，捉虫子的工作就永远也不会结束。

*比如，OA系统的动态业务表单为例，如果以为界面为中心的实现方式，会导致业务逻辑，存储层、业务逻辑层和表示层代码混杂在一起，既无从下手进行性能优化、也无法产生中间结果进行缓冲。*

**BO**构建的中间层包括了业务数据和逻辑，向上可以转换成表示层所用的**VO**，向下可以转换为数据层的**PO**，自身也可有独立缓存，结合缓存框架和IOC框架使用。

>**代码是相互依存的，如同一句话不会单独存在。**

##各种各样的依赖症##
>**手里拿着一把锤子，看什么都像钉子。**

由于各自的项目经验，程序员会患上各种各样的依赖症，比如 **IDE依赖症，数据库依赖症，SQL语句依赖症，编辑器/生成器依赖症，框架依赖症，数据集(DataSet)依赖症...**。

这些依赖症源自基本技能经过长期使用，从心理上认为这些工具和组件是安全的，甚至可以超出组件自身设计功能翻出很多花样，来解决各种状况。
问题是在特定的业务领域，这些手段是非常合理的，但依赖症表现为不考虑实际应用场景随意的使用这些现成的组件。

方法本身没有问题，问题出在方法论上，从项目一开始就建立起一个组件的依赖，不利于项目的成长。

比如对数据库的依赖从一开始就把数据库实现的细节和技术复杂度强行加到了核心部件上。
项目初始时，业务逻辑/核心部件是没有任何外部依赖的，数据库依赖症所增加的外部依赖直接增加单元测试的复杂度。

虽然有很多 IoC（控制反转）/ORM 框架来解决外部依赖的状况，但是核心问题如果不解决，SqlServer 和 MySql 是没有什么区别的，框架只能解决兼容不同数据库的问题，不能解决用不用数据库的问题。

>**云时代，需要的是全栈思维，全面解构的思维。**




**目录**
>- [引子](引子.md)
- [1、从代码风格说起](1.从代码风格说起.md)
- [2、解构的目标](2.解构的目标.md)
- [3、稳固的中间层](3.稳固的中间层.md)
- [4、BO的TDD](4.BO的TDD.md)
- 未完待续

> Written with [StackEdit](https://stackedit.io/).