分布式网络数据缓存概要设计
==========================

#概述#
分布式网络系统中最常见的是Web站点，通过浏览器就可以直接访问的网络资源。
还有一些专门的网络系统，比如电子邮件、即时通讯、p2p网络下载、网络游戏等。
其中Web系统数量最多，采用的技术架构也比较开放，经过多年发展，已经形成了多层数据缓存结构和独立的缓存服务。

在 HTTP 1.1 协议设计中考虑了Web资源的缓存问题，主要通过两个标记实现，一个是 Cache-Control(缓存过期模型)和ETAG(缓存Hash)。缓存过期时间（Expiration time）用于指示如何更新缓存条目，特别是指明了清理和替换条目的策略。ETAG 才是条目是否变更的标志。
从整个缓存流程中看，设计一个系统缓存架构都离不开这两个重要的策略，即缓存清理策略和资源Hash标识。

##应用目标
活动模板系统的应用缓存数据的目的是为了提高离线处理的能力，节省带宽，提高系统启动和响应的速度。
和HTTP 网络协议缓存功能设计不同的是，此缓存的设计中生产者同时也是消费者，消费者同时也是缓存代理。
1、离线处理
支持系统在无法访问网络或者网速比较慢的情况下，能够打开访问过的内容。

2、提速能力
    提速能力体现在以下几个方面
    - 充分利用缓存数据，减少重复请求已有的数据。
    - 能够检测到数据版本变更，只下载变更的文件
    - 

##技术要点
在活动模板的应用领域中，系统通过消息进行传递，

 - 缓存生命期策略
 - 资源Hash 标识
 - 差分数据传输
 - 缓存资源存储
 - 消息数据缓存规则

###生命周期策略
缓存回收优先级应当可以用数字量化，可以排序和比较以便确定哪个资源先被回收。这个回收优先级又和保存的起始日期相关，所以过期日期正好可以满足这两点需求，回收优先高一些的过期时间也比较短。这样看来，回收优先级的表述不是很恰当，更明确的提法是失效期。对于更新比较频繁的资源，过期时间可以设定的短一些，以至于为 0，即不进行缓存。
真正要讨论的是，在一组资源里面，不同的内容资源优先级是不同的

###资源Hash

###差分数据传输
差分传输能够最大限度的节省网络流量，

###资源分类
 1. 静态资源
    静态资源包括页面文件、XML资源文件、模板文件、CSS样式文件、图片/视频文件等。
 2. 动态数据
 3. 认证信息
 4. 消息数据

###缓存寿命周期


#缓存体系结构设计
##Web系统缓存结构
 下面先简单分析一下最常见的Web系统的缓存处理策略。
Web系统的数据传输分为几个层次，静态资源，动态页面和消息。从缓存的角度分析分为可以缓存的内容和不可以缓存的内容。
###静态资源
包括的内容有
 - 静态页面
 - 图片
 - 脚本库
 - 样式表
###动态页面
 动态页面是指由系统计算出来的页面和页面部件。
动态页面通过指定生命周期来
###消息
 最常用的消息比如 JSON ，这类数据可以和动态页面很类似，
 会给出一个失效期，

 Web 架构中的缓存模型采用责任链的模式把数据更新一层一层推送到

###CDN
即内容分发网络，部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商那里，在这里缓存网站的一些静态资源（较少变化的数据），可以就近以最快速度返回给用户，如视频网站和门户网站会将用户访问量大的热点内容缓存在CDN。 
###反向代理
反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问到的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器就能返回给用户。 
###本地缓存
在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而无需访问数据库。 
###分布式缓存
大型网站的数据量非常庞大，即使只缓存一小部分，需要的内存空间也不是单机能承受的，所以除了本地缓存，还需要分布式缓存，将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。 
使用缓存有两个前提条件，一是数据访问热点不均衡，某些数据会被更频繁的访问，这些数据应该放在缓存中；二是数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因已经失效而产生脏读，影响结果的正确性。网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力，这一点对网站数据库架构至关重要，网站数据库几乎都是按照有缓存的前提进行负载能力设计的。

##参考模型
###Web 缓存架构
####3.1  Web缓存体系结构
一个Web缓存系统的性能取决于其客户群的大小，客户群越大，缓存的内容被再次请求的可能性就越高。相互合作的Cache组可能会提高命中率而提高缓存系统的性能，因此缓存系统的体系结构应确保代理间能够有效地进行合作。典型的缓存体系结构有以下几种：层次式、分布式和混合式。

图1 Web缓存系统体系结构图
#####3.1.1 层次式缓存体系结构
Harvest项目[3]首先提出了层次式Web缓存体系结构。在层次式缓存体系结构中，Cache在网络呈多级配置，如图1（a）所示。为简单起见，假定有四级：底层Cache、局域层Cache、区域层Cache、广域层Cache。底层是客户/浏览器Cache，当客户端Cache不能满足客户的请求时，该请求被转发到局域层Cache，如果仍然得不到满足，则该请求被转发到区域层Cache直至广域层Cache。如果该请求在各级Cache中都得不到满足，则请求最终被转发到服务器。然后服务器对该请求的响应自顶向下地发送给客户，在沿途的每一个中间层Cache中留下一个副本。请求相同内容的其它请求则自下而上地进行转发，直到在某一级Cache中得到满足。
层次式缓存体系结构带宽效率高，点击率较高的Web内容可以快速高效地分布到网络中。但该体系结构也存在一些不足[4]：
（1）建立层次式缓存体系结构，缓存服务器必须配置在网络中关键的访问点上，缓存服务器间需相互合作；
（2）每一级Cache都会带来额外的延迟；
（3）高层Cache可能会成为瓶颈并带来较长的排队延迟；
（4）同一个内容的多个副本被保存在不同的Cache中，整个系统Cache空间利用率不高。
#####3.1.2 分布式缓存体系结构
针对层次式缓存结构的上述缺陷，一些研究者提出了分布式缓存体系结构，在这种结构中，只有低层Cache,如图1（b）所示。文献[5]中的分布式Web缓存结构中，没有超出局域层的中间Cache层，Cache之间相互协作以处理失效。为了确定将客户请求转发给哪一个局域层Cache来获取失效的内容，每一个局域层Cache保留一份其它局域层Cache中缓存内容的目录信息，以便发生失效时将客户请求准确地转发到相应的局域层Cache。缓存阵列路由协议CARP [6]（Cache Array Routing protocol）是一种分布式缓存方案，它将URL空间分割成不同的部分，将每一部分指定给一组松散耦合的Cache组，每个Cache只能缓存具有指定给它的URL的Web内容，从而可以根据客户请求内容的URL来确定将请求转发给哪一个Cache。
在分布式缓存结构中，大多数的网络流量都发生在网络底层，不容易产生网络拥塞，Cache空间利用率高，且可以更好地实现负载共享，容错性更好。然而，一个大规模的分布式缓存系统的配置可能会遇到几个问题：连接次数较多、带宽要求高、管理困难[4]。
#####3.1.3 混合式缓存体系结构
混合式体系结构如图1（c）所示，同级Cache采用分布式缓存结构，相互合作。Harvest集团设计的互联网缓存协议ICP（the Internet Cache Protocol）支持从RTT最小的父Cache或邻居Cache中获取相应的内容。
#####3.1.4 缓存体系结构的优化
研究表明[4]层次式缓存体系结构和分布式缓存结构相比，层次式缓存体系结构具有较短的连接时间，因此将较小的文档缓存在中间层Cache中可以减少访问延迟；分布缓存结构具有较短的传输时间和较高的带宽利用率。理想的方案就是将二者结合起来，充分发挥各自的长处，同时减少连接时间和传输时间。
####3.2  缓存路由
出于对Web缓存系统扩展性的考虑，大多数缓存系统将大量的Cache分散在互联网上，这样带来的最大问题是如何快速地定位缓存有所需内容的Cache，这就是缓存路由问题。该问题有点类似于网络路由，但却不能用同样的方式解决。传统的网络路由可依地址聚类（层次式的地址表示使得地址聚类成为可能）而进行，但是在WWW中，具有相同URL前缀或服务器地址前缀的文档未必发送给相同的客户，难以对路由地址进行聚类，这样缓存路由表将大得难以管理。此外，缓存内容不断更新，过时的缓存路由信息将导致缓存失效。为降低Cache失效的代价，理想的缓存路由算法应该将客户的请求路由到下一个代理，该代理具有较高的命中可能性且位于或接近于客户到服务器的网络路径上。

#####3.2.1 缓存路由表法
Malpani等人[7]将一组Cache组合起来，当客户的请求被转发到指定的Cache时，如果该Cache缓存有请求的内容，则将其发送给客户，否则通过IP组播将请求转发给同组的其它Cache，由缓存有相应内容的Cache对客户的请求进行响应，如果所有Cache中都没有缓存请求的内容，则该请求被转发到源服务器。Harvest[3]缓存系统将Cache组织成层次式结构并使用Cache解析协议ICP（Internet Cache Protocol），当发生Cache失效时，低层Cache在将客户请求转发到上一层Cache前，首先查询兄弟节点Cache是否缓存有相应的内容，以避免顶层Cache超载。自适应Web缓存系统[8]为每一个服务器建立Cache树，树中的Cache被组织成相互重叠的多点传送组，一个请求通过这些传送组来获取相应的缓存内容。该方法对每一个服务器构造不同的Cache树，因此没有根结点的超载问题，自配置性和鲁棒性都比较好。但是对点击率较低的内容请求可能会经过较多的Cache，产生较大的Cache通信开销，作者建议通过限制请求经过的Cache数来解决该问题。

#####3.2.2 哈希函数法
Cache阵列路由协议CARP[6]使用一个基于阵列成员列表和URL的哈希函数来确定一个Web对象确切的缓存地址或一个Web对象应缓存在什么地方。在Summary Cache[9]中，每个代理保存一个同组中其它代理所缓存内容的URL摘要信息，该代理在转发客户请求时检查这些摘要信息以确定将请求转发给哪一个代理。为减小开销，这些摘要信息定期进行更新。试验表明该系统可以显著地减少Cache间的信息数量、带宽消耗以及协议带来的CPU开销，而保持和ICP几乎一样的缓存命中率。

####3.3  Cache替换算法
Cache替换算法是影响代理缓存系统性能的一个重要因素，一个好的Cache替换算法可以产生较高的命中率。目前已经提出的算法可以划分为以下三类：
（1）传统替换算法及其直接演化，其代表算法有：①LRU（Least Recently Used）算法：将最近最少使用的内容替换出Cache；②LFU（Lease Frequently Used）算法：将访问次数最少的内容替换出Cache；③Pitkow/Recker[10]提出了一种替换算法：如果Cache中所有内容都是同一天被缓存的，则将最大的文档替换出Cache，否则按LRU算法进行替换。
（2）基于缓存内容关键特征的替换算法，其代表算法有：①Size[10]替换算法：将最大的内容替换出Cache；②LRU—MIN[11]替换算法：该算法力图使被替换的文档个数最少。设待缓存文档的大小为S，对Cache中缓存的大小至少是S的文档，根据LRU算法进行替换；如果没有大小至少为S的对象，则从大小至少为S/2的文档中按照LRU算法进行替换；③LRU—Threshold[11] 替换算法：和LRU算法一致，只是大小超过一定阈值的文档不能被缓存；④Lowest Lacency First[12]替换算法：将访问延迟最小的文档替换出Cache。
（3）基于代价的替换算法，该类算法使用一个代价函数对Cache中的对象进行评估，最后根据代价值的大小决定替换对象。其代表算法有：①Hybrid[12] 算法：算法对Cache中的每一个对象赋予一个效用函数，将效用最小的对象替换出Cache；②Lowest Relative Value[13] 算法：将效用值最低的对象替换出Cache；③Least Normalized Cost Replacement（LCNR）[14]算法：该算法使用一个关于文档访问频次、传输时间和大小的推理函数来确定替换文档；④Bolot等人 [15]提出了一种基于文档传输时间代价、大小、和上次访问时间的权重推理函数来确定文档替换；⑤Size—Adjust LRU（SLRU）[16] 算法：对缓存的对象按代价与大小的比率进行排序，并选取比率最小的对象进行替换。
总之，为了使Cache命中率最大化，围绕Cache替换算法已经开展了大量的工作，但是替换算法的性能很大程度上取决于WWW访问的特性，还没有哪一种替换算法能够对所有Web访问模式都优于其它算法。

####3.4 缓存一致性
Web缓存系统可以减小访问延迟，但带来了一个副作用：缓存的副本提供给客户的可能是过时的内容，因此必须有一套缓存一致性机制来确保缓存的内容能够及时进行更新及有效性确认，以便为客户提供最新的内容。
目前主要有两种缓存一致性类型：强缓存一致性和弱缓存一致性。
3.4.1 强缓存一致性
（1）客户端确认：对于每一次访问，代理都认为缓存的内容已经过时并随请求发送一个“IF—Modified —Since—date”报头到服务器。如果在指定的时间后该内容发生了变化，则服务器将更新后的内容发送给代理并最终发送给客户；如果请求内容未修改，则发回 “304”响应，表示文档未修改，缓存内容继续有效。
（2）服务器确认：当服务器检测到一个内容发生变化时，服务器向所有最近请求过该内容并有可能缓存该内容的客户发送作废信息[17]。该方法要求服务器必须保存一个访问该内容的客户链表以便发送作废信息，当客户数量很大时，该方法将变得不适用，同时，该链表本身也可能过时，造成服务器向许多已经不再缓存该内容的客户发送作废信息。

####3.4.2 弱缓存一致性
（1）自适应TTL[18] （Time To Live）机制：通过观察一个文档的生存期来调整其生存时间，从而解决缓存一致性问题。如果一个文档在一个相当长的时间内都未修改过，它往往不会再发生变化。这样，一个文档的生存期属性被赋予一个该文档目前“年龄”（等于目前时间减去上一次修改的时间）的百分比。自适应TTL法可以将一个文档过时的可能性控制在＜5%的范围内。大多数的代理服务器都使用该机制，但是这种基于文档生存期的缓存一致性机制并不能确保缓存内容的有效性。
（2）捎带作废机制
Krishnamurthy等人提出使用捎带作废机制来提高缓存一致性的效率。他们提出了三种机制：①捎带确认PCV[19]（Piggyback Cache Validation）机制：利用代理发送给服务器的请求来提高缓存一致性。例如，当一个代理向服务器发出请求时，它捎带一系列缓存的但可能过时的来自该服务器的内容进行有效性确认；②捎带作废PSI[20]（Piggyback Service Invalidation）机制：其基本思想是当服务器对代理进行响应时，把一系列上次代理访问后变化的内容告诉代理服务器并由代理将这些内容作废，从而延长其它缓存内容在Cache中的缓存时间；③PSI和PCV混合机制[21]：该机制根据代理上次请求作废的时间距当前时间间隔的大小来确定采用何种机制，以实现最佳的总体性能。如果这个时间间隔较小，则使用PSI机制，否则使用PCV机制来对缓存内容进行确认。其基本原理是时间间隔越小，与PSI一起发送的作废数量就小，但随着时间的增长，发送作废的开销将大于请求确认的开销。

####3.5 内容预取
Web缓存技术可以提高Web性能，但研究表明[22]，不管采用何种缓存方案，最大缓存命中率通常不大于40～50%。为进一步提高缓存命中率，引入了预取技术。预取技术本质上是一种主动缓存技术，其基本思想是在处理客户的当前请求时，利用客户访问内容或模式的先验知识，对客户接下来的请求内容进行预测，并利用客户请求的间隙将预测内容缓存在Cache中，从而更好地隐藏延迟，提高服务质量。
早期研究集中在浏览器/客户与Web服务器之间进行内容预取，当代理被引入后，人们的研究兴趣转到了代理与服务器之间的预取技术研究。研究表明预取技术可以有效地降低客户访问延迟，但预取技术仍饱受争议，原因有二：
（1）内容预取是一种实时性要求较高的任务，它主要利用客户请求的间隔进行，而这个间隔一般情况下小于一分钟[23]，如果在这段时间内不能完成预取任务，预取将变得毫无意义。因此对预取算法的效率有较高的要求。
（2）内容预取是通过加重服务器负载及增加网络流量为代价来降低客户端响应时间的，因此对预取的准确度有较高的要求。同时，一个预取模型在确定预取文档的数量时，必须考虑客户的访问特性、服务器负载及网络流量状况，如果抛开这些因素来进行预取可能会造成事与愿违的效果。
总之，一个良好的预取模型，效率、准确度要高，付出代价小。围绕预取的高效性和准确性还需做进一步的研究。

####3.5 负载平衡
当众多客户同时从一台服务器获取数据或服务时就会发生Hot Spot现象，导致服务器性能下降甚至失效。目前处理该问题的方法大多数是使用某些复制策略将被请求的内容分贮在互联网上，从而将负载分散到多个服务器（代理）上[24]，避免单个服务器成为为瓶颈。
3.6  缓存内容
一个代理可能发挥多种作用，除进行数据缓存外还可以进行连接缓存和计算缓存。连接缓存指在客户与代理、代理与服务器间使用持久连接，来减少建立TCP连接开销及服务器发送时的慢起动开销，从而减小客户访问延迟时间[25]。计算缓存可以看作是Web服务器可以将它们的部分服务迁移到代理，以减轻服务器瓶颈，其应用之一就是动态数据缓存，通过代理来缓存动态数据并将一部分计算迁移到代理，由代理来产生和维护缓存的动态数据，从而提高客户获取动态数据的性能。

### Web 缓存总结
需要指出的是，虽然Web缓存机制存在多种模型，实际上大多数还是属于 B/S 框架内的，即 Web Server 缓存机制用于 Web集群内部，而不是基于整个网络，浏览器本地的缓存（HTTP Cache）采用协商机制确定缓存保持的期限。
另外有一些比较特殊的缓存服务，部署在本地网关，比如使用反向代理技术作为缓存代理服务器进行外网访问的缓存，其应用面比较特殊。
应用更为广泛的是 CDN （内容分发网络）、网络镜像服务，作为一类资源类缓存服务，解决的是相对稳定的网络资源，比如脚本库、视频资源等，**这些资源本身具有版本控制和明确的失效期限，比较容易进行缓存处理**。
*（如何定义这些容易做缓存的资源特征？？）*

###HTTP 缓存机制
简单的说HTTP缓存利用超时时间和 ETAG标记对需要缓存数据进行标记，同时


###Diff 算法
> - http://en.wikipedia.org/wiki/Diff
> - http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
> - http://en.wikipedia.org/wiki/Dynamic_programming
> - http://xw2k.nist.gov/dads/



###Git
Git 分布式版本控制系统具有很多优秀的特点，对于需要版本管理的缓存功能来说具有相当的借鉴意义。
####Git 特点总结
1、不是采用保存原始版本完整副本，然后记录变更内容的方式，而是正好相反，保留最终版本的完整副本，保留上版本的差异。经常用到的是最终版本，而原始版本用到的机会比较小。
2、通过 SHA1 hash 对文件标记文件版本。
3、针对整个目录（项目）进行版本控制。
4、支持本地的版本库，分布式

###Git 设计目标
 - 速度
 - 简单的设计
 - 对非线性开发模式的强力支持（允许上千个并行开发的分支）
 - 完全分布式
 - 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）

###Git 特点
#####直接记录快照，而非差异比较
Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图 1-4。
![图 1-4. 其他系统在每个版本中记录着各个文件的具体差异](http://git-scm.com/figures/18333fig0104-tn.png)

Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。Git 的工作方式就像图 1-5 所示。

![图 1-5. Git 保存每次更新时的文件快照](http://git-scm.com/figures/18333fig0105-tn.png)

**这是 Git 同其他系统的重要区别。**它完全颠覆了传统版本控制的套路，并对各个环节的实现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的超强工具，而不只是一个简单的 VCS。稍后在第三章讨论 Git 分支管理的时候，我们会再看看这样的设计究竟会带来哪些好处。

#####近乎所有操作都是本地执行#####
在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。但如果用 CVCS 的话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快。

举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本地来作比较。

用 CVCS 的话，没有网络或者断开 VPN 你就无法做任何事情。但用 Git，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程仓库。同样，在回家的路上，不用连接 VPN 你也可以继续工作。换作其他版本控制系统，这么做几乎不可能，抑或非常麻烦。比如 Perforce，如果不连到服务器，几乎什么都做不了（译注：默认无法发出命令 p4 edit file 开始编辑文件，因为 Perforce 需要联网通知系统声明该文件正在被谁修订。但实际上手工修改文件权限可以绕过这个限制，只是完成后还是无法提交更新。）；如果是 Subversion 或 CVS，虽然可以编辑文件，但无法提交更新，因为数据库在网络上。看上去好像这些都不是什么大问题，但实际体验过之后，你就会惊喜地发现，这其实是会带来很大不同的。

#####时刻保持数据完整性
在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。

Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个 SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起来就像是：
>24b9da6552252987aa493b52f8696cd6d3b00373

Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。

#####多数操作仅添加数据
常用的 Git 操作大多仅仅是把数据添加到数据库。因为任何一种不可逆的操作，比如删除数据，都会使回退或重现历史版本变得困难重重。在别的 VCS 中，若还未提交更新，就有可能丢失或者混淆一些修改的内容，但在 Git 里，一旦提交快照之后就完全不用担心丢失数据，特别是养成定期推送到其他仓库的习惯的话。

这种高可靠性令我们的开发工作安心不少，尽管去做各种试验性的尝试好了，再怎样也不会弄丢数据。至于 Git 内部究竟是如何保存和恢复数据的，我们会在第九章讨论 Git 内部原理时再作详述。

#####文件的三种状态
好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。

由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。

![图 1-6. 工作目录，暂存区域，以及本地仓库](http://git-scm.com/figures/18333fig0106-tn.png)

每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone --bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。

从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。

所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。

基本的 Git 工作流程如下：

 1. 在工作目录中修改某些文件。
 2. 对修改后的文件进行快照，然后保存到暂存区域。
 3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。
 
 所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。到第二章的时候，我们会进一步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。

####文件的状态变化周期
工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。

在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图 2-1 所示。
![图 2-1. 文件的状态变化周期](http://git-scm.com/figures/18333fig0201-tn.png)
#####检查当前文件状态
>git status (略)
#####增加文件跟踪
>git add ...
######暂存已修改文件（略）
######忽略某些文件
创建一个名为 .gitignore 的文件，列出要忽略的文件模式
#####提交更新
现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：

>$ git commit
或者 用 -m 参数后跟提交说明的方式
>$ git commit -m "Story 182: Fix benchmarks for speed"
或则 跳过使用暂存区域
尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：
>git commit -a -m 'added new benchmarks'
#####移除文件
要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

#####移动文件
不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。

既然如此，当你看到 Git 的 mv 命令时一定会困惑不已。要在 Git 中对文件改名，可以这么做：

>$ git mv file_from file_to
其实，运行 git mv 就相当于运行了下面三条命令：

>$ mv README.txt README
$ git rm README.txt
$ git add README
如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 git mv 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。


#####文件追踪规则


###Git objects
>Git 是一套内容寻址文件系统。Git 从核心上来看不过是简单地存储键值对（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。

###Git Tree

