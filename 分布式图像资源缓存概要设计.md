分布式图像资源缓存概要设计
======================

#一、序言#
接到这么一个需求，需要在互联网范围内提供快速的数据资源访问，数据资源的特征是如大型图片、视频等。出于响应速度的考虑，需要进行多级缓存处理。
初看起来有些像现在的网络视频和网络电视服务，把大量的点播服务转变成广播式服务。
这样讲也不完全准确，应该像是热点视频，其实网络视频服务商会把更多的资源提供给热点项目，小众的项目由于访问人数较少，响应速度影响不大，反倒是访问的人数越多，响应速度越快。

#二、应用场景#
可以想见的应用场景可以分为以下几类
##1. 云端服务器
由于带宽和各类宽带网络的网关接口限制，通常公共的云服务需要在多个网络上部署云服务器，以保证响应速度。

##2. 个人电脑/平板电脑##
个人电脑作为使用者同时也可以部分分担缓存共享的功能，但是由于服务质量不稳定，和用户是否授权使用的限制，很难起到效果。
这方面有几个案例

 - 电驴/迅雷/P2P协议
    纯资源下载加速

 - 快播
    快播真是一个奇葩，从技术上讲比那些成功的视频网站还要先进，它充分利用了热点效应进行资源加速，热门视频很容易在附近找到资源，减少网络压力。

下面是快播技术特点的摘要（只摘录了和网络/性能 有关的部分）

> - 独创的网络即时流接收播放技术，支持BT种子文件的直接播放 。
- 支持P2P流媒体播放时的任意拖拽，支持网络数据流的控制 。
- 高效的NAT和防火墙穿透能力，帮助内网用户加快传输速度 。
- 支持DHT网络，当连接不到Tracker服务器时也能获取到数据 。
- 软件小巧精致，优化的安装包仅1M多，占用极少的系统资源 。
- 使用多线程技术接收并整合流媒体数据，以达到最快速播放目的 。
- 快中求稳，流畅体验：采用P2P技术，有效改善网络点播过程中画面拖尾现象，保证画面整体流畅性。
- 5秒加速，快速观影：只要用5秒甚至不到5秒的时间完成在线视频缓冲，短小视频可实现零等待。
- 节省资源，提高效率：对CPU、内存占有率较低，避免出现死机或卡机等状况，提高软件运作效率。
- 高清影院，轻松拥有：快播移动端进行转码后可播放720P以上的高清视频，让你轻松拥有掌上电影院。
- 流媒体播放优化：可以实现不读取流媒体的索引，直接播放。
 
- P4P加速

>QVOD是基于**UDP协议**传输的，针对流媒体点播进行**P4P加速**的流媒体点播系统。
完全穿透**防火墙及NAT**，实现真正内网与内网之间全连接，完全扩大种子的覆盖率。使得在90%以上的内网用户均可以成为最有效的积极的上传贡献种子，使得90%以上的所有加入P4P网络传输的节点，均可以有效的利用其上行、下行带宽。
QVOD文件块的**请求及校验传输**更加准确，减少了大量的无效的请求及文件发送，大大节省了网络带宽的无效占用。
QVOD以互联网用户群为基础的P4P加速技术，保证了点播对服务器的低带宽占用和低资源占用，保证了流媒体文件传输的高清晰和高流畅，真正可以达到用**户数越多，播放速度越快**。传统点播服务不但地域受局限，服务规模一旦成长就面临瘫痪，有QVOD点播系统再也不用为此担心。

##3. 电视盒/智能路由器##
目前智能路由器发展迅速，特别是计算能力和存储空间已经直逼个人电脑。和平板电脑/笔记本电脑这类移动计算设备相比，由于直接供电，基本不用考虑电池续航能力，所以是一类新兴的服务类计算设备，可以简单的想象为一个小型的服务器。

#四、P2P/P4P#
P2P 技术和后来产生的 P4P 是以网络内容共享技术，由内容热点而产生共享的可能。
P4P 是站在全网优化的角度上产生的，从思路上看是没有问题的。
但是经过几年的炒作，大量没有视频资源的终端产品涌入，直接把P4P做死了。
野蛮增长的P2P无序的数据流量给网络带来很大的负担，甚至影响了正常的数据流量。
这方面有一些研究和分析，大致的结论就是用 P4P 替代P2P。
从运营商角度来看，P4P技术涵盖视频点播、镜像服务、CDN数据分发网络等服务，可以作为一种可运营的服务。

我们这里借鉴的意义在于
1. 资源数量的不确定性，和云服务的思路是想通的，系统内部的计算资源是可伸缩的，可以随时增加或减少计算资源。


#三、分布式缓存运行机制#
分布式缓存有几个规则需要先搞清楚。
##3.1 资源定位##
资源定位从形式上采用 URI *(uniform resource identifier，统一资源标识符，用来唯一的标识一个资源.)*形式。格式上采用 URL 的格式。
作为内部使用的一种资源定位标识，可以不
对于分布式资源来说，资源请求无法明确指定到某个主机地址，所以 http协议采用的URL 格式是不能用的。
从形式上看，可能更像一个分散的

###3.1.1 URI###
虽然编程时经常使用 Uri 但是对其概念还是没有仔细研究过，只是使用特定的Uri 规则，而没有建立过自己专属的规范。
>首先，**URI**(*uniform resource identifier*，*统一资源标识符*)，用来唯一的标识一个资源。而**URL**是*uniform resource locator*，*统一资源定位器*，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。而**URN**(*uniform resource name，统一资源命名*)，是通过名字来标识资源，比如mailto:java-net@java.sun.com。也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。**URL**和**URN**都是一种**URI**。
在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的，schema必须被指定。
那么对于Image 资源，到底是imgUrl好呢，还是imgUri好？显然，如果说imgUri是肯定没问题的，因为即使它实际上是url，那它也是uri的一种。那么用imgUrl有没有问题呢？此时则要看它的可能取值，如果是绝对路径，能够定位的，那么用imgUrl是没问题的，而如果是相对路径，那还是不要用ImgUrl。总之，用imgUri是肯定没问题的，而用imgUrl则要视实际情况而定。
另外，从HttpServletRequest的javadoc中可以看出，getRequestURI返回一个String，“the part of this request’s URL from the protocol name up to the query string in the first line of the HTTP request”，比如“*POST /some/path.html?a=b HTTP/1.1*”，则返回的值为”*/some/path.html*”。现在可以明白为什么是getRequestURI而不是getRequestURL了，因为此处返回的是相对的路径。而getRequestURL返回一个StringBuffer，“*The returned URL contains a protocol, server name, port number, and server path, but it does not include query string parameters.*”，完整的请求资源路径，不包括querystring。
总结：URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的，而通常说的relative URL，则是针对另一个absolute URL，本质上还是绝对的。

>- URI抽象结构 [scheme:]scheme-specific-part[#fragment]
- [scheme:][//authority][path][?query][#fragment]

####3.1.2 Uri 参考####
- ed2k Uri 结构
 > - **基本ed2k链接** *ed2k://|file|<文件名称>|<文件大小>|<文件哈希值>/*
- **eD2k片段哈希值链接**　 *ed2k://|file|<文件名称>|<文件大小>|<文件哈希值>|p=<片段哈希值>/*
- **eD2k 来源链接**         *ed2k://|file|<文件名称>|<文件大小>|<文件哈希值>/sources, < IP:端口>/*
- **eD2k 主机链接**         *ed2k://|file|<文件名称>|<文件大小>|<文件哈希值>/sources,<主机名称:端口>/*
- **eD2k HTTP 来源链接**    *ed2k://|file|<文件名称>|<文件大小>|<文件哈希值>|s=http://any.com/文件名称/*
- **eD2k 根哈希值链接**     *ed2k://|file|<文件名称>|<文件大小>|<文件哈希值>|h=<根哈希值>/*

从以上资料可以看出，建立分布式资源缓存的 Uri 规范需要三部分，Scheme、authority 和 资源Id

###3.1.3 Scheme###
(*未完成*)

###3.1.4 Authority###
(*未完成*)

###3.1.5 资源Id###
资源Id 是内容资源唯一标识符，需要在全网络范围内唯一标识资源对象。资源Id用做内容资源的主索引。
通常采用 Hash 算法进行资源内容标识。
在以往的项目中，使用 MD5 算法计算文件流的Id,MD5 生成128位的Hash码，正好符合 Guid 结构要求，在数据库中使用 Guid 作为主键使用。

网络上通常采用SHA1 算法生成文件哈希和 文件校验码
如 [BitTorrent](http://www.bittorrent.org/beps/bep_0003.html) 中使用的就是20个字节的 SHA1 Hans
>info_hash
The 20 byte sha1 hash of the bencoded form of the info value from the metainfo file. Note that this is a substring of the metainfo file. The info-hash must be the hash of the encoded form as found in the .torrent file, regardless of it being invalid. This value will almost certainly have to be escaped.
####Hash 算法####
主要从3个方面考察 Hash 算法,1、碰撞概率，2、算法资源消耗，3、哈希值长度

- MD5
 - 碰撞概率，2004年，王小云证明MD5数字签名算法可以产生碰撞[2]。2007年，Marc Stevens，Arjen K. Lenstra和Benne de Weger进一步指出通过伪造软件签名，可重复性攻击MD5算法[3]。研究者使用前缀碰撞法（chosen-prefix collision），使程序前端包含恶意程序，利用后面的空间添上垃圾代码凑出同样的MD5 Hash值。
2008年，荷兰埃因霍芬技术大学科学家成功把2个可执行文件进行了MD5碰撞，使得这两个运行结果不同的程序被计算出同一个MD5。2008年12月一组科研人员通过MD5碰撞成功生成了伪造的SSL证书，这使得在https协议中服务器可以伪造一些根CA的签名。
 - 128位 16字节
- SHA1
 - SHA1 算法的哈希值大小为 160 位 20字节
- SHA512
 - SHA512 算法的哈希值大小为 512 位 64字节。

##3.2 资源寻址和内容分发 ##
和典型的 P2P 网络不同，内容原版主要存在于分发的个人， 建立资源后需要存储到云端进行版权保护。
资源缓存中不涉及原始资源的存储，

##3.3 缓存信息结构##
这里不准备对缓存内容信息进行详细的设计，只是先简要规划一下信息结构。
内容特征、 内容来源、摘要信息、版权信息

###3.3.1 内容特征###
根据不同的分类，每种资源会有自己的特征信息表。特征表用于资源检索功能。
对于图像资源来说，有些很难用文字的表述清楚，那么需要用相似性进行描述。
图像的基本特征：色调、风格、是否包含人像、是否包含可识别的文字等等。
需要专门用于描述的索引和检索方法。

###3.3.2 内容来源###
内容来源用于指引找到原始内容资源。

###3.3.3 摘要信息###
摘要信息为用户提供资源的详细描述和预览，比如图片资源的描述内容、图片预览等。
根据列表层次，摘要信息也需要分成列表摘要，详细摘要。
比如预览图片也有图标、小图和大图预览。

###3.3.4 版权信息
（*未完成*）

#四、参考模型
##4.1 反向代理
反向代理是网站缓存的常用技术，通过代理对数据进行转发，在代理中可以增设内容缓存。
通过主服务器确定用户所在网段，找到最近的缓存服务器，通过反向代理的方式让缓存服务器完成缓存代理的功能。

>反向代理可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于本地WEB服务器和Internet之间，处理所有对WEB服务器的请求，阻止了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。这种方式通过降低了向WEB服务器的请求数从而降低了WEB服务器的负载。

 > Written with [StackEdit](https://stackedit.io/).